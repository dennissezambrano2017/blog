export const blogList = [
    {
      id: 1,
      title: 'Introducción a la Computación Distribuida',
      category: 'Computación Distribuida',
      subCategory: ['Arquitectura', 'Fundamentos', 'Introducción'],
      description:
      "La computación distribuida es un modelo para resolver problemas de computación masiva utilizando un gran número de ordenadores organizados en clústeres incrustados en una infraestructura de telecomunicaciones distribuida.",
      description2: "La computación distribuida se usa en muchos campos porque es un modelo de computación que usa un software que permite cálculos a gran escala y funciona distribuyendo información entre miles de computadoras que envían sus resultados a un solo servidor. Compartir recursos remotos para realizar tareas en lugar de realizarlas desde una sola estación de trabajo permite una mayor seguridad, eficiencia y confiabilidad. Estas son las principales características de los modelos de computación distribuida: Que la información tengo un acceso seguro mediante procesos remotos, que los recursos utilizados sean eficientes, la fiabilidad de las redes de comunicación, que se usan para transferir datos y los estándares o protocolos abiertos al desarrollador. Dentro de la computación distribuida se pueden clasificar tres modelos considerados estándares en el mundo de la informática y las redes: Cloud computing, Grid computing, Cluster computing.",
      description3: "La computación en la nube (Cloud computing) es aquel ainfraestructura de servicios y plataformas escalables que son accesibles para el conjunto de usuarios a través de la internet, este tipo de computación adquiere tres submodelos, el primero de ellos es el Software como Servicio o (SaaS), luego está la Plataforma como Servicio (PaaS) y por último, la Infraestructura como Servicio (IaaS). La computación en malla (Grid computing) es aquella que un ordenador con fuerte capacidad informática adquiere funcionamiento gracias a un grupo de ordenadores conectados, esto sirve para proyectos o procesos criptográficos donde la demanda de resolución masiva y pesada de algoritmos y problemas matemáticos. La computación en clúster (Cluster computing), es nada más y nada menos que un conjunto de ordenadores que trabajan como nodos, trabajando conjuntamente y combinan sus capacidades informáticas para realizar tareas de mediano y alto rendimiento, esto se utiliza mucho en el área de la Ciencia de datos.",
      authorName: 'RICARDO TURRIAGO',
      authorAvatar: '/assets/images/turriago.jpg',
      createdAt: '3 de junio/2022',
      cover: '/assets/images/apps1.jpg',
      refer: ["SAP España, “Computación distribuida: qué es, cómo funciona, ventajas y desventajas,” SAP España News Center, Apr. 06, 2021. https://news.sap.com/spain/2021/04/computacion-distribuida-que-es-como-funciona-ventajas-y-desventajas/#:~:text=La%20computaci%C3%B3n%20distribuida%20se%20utiliza,resultados%20a%20un%20mismo%20servidor (accessed Sep. 09, 2022).", 'J. Roca, “¿Por qué la computación distribuida no es computación en la nube?,” HardZone, Dec. 21, 2020. https://hardzone.es/reportajes/que-es/computacion-distribuida/ (accessed Sep. 09, 2022).'],
      imgs1:'/assets/images/Semana1_1.png',
      imgs2: '/assets/images/Semana1_2.png',
    },
    {
      id: 2,
      title: 'Paradigmas de las Aplicaciones Distribuidas',
      category: 'Paradigmas',
      subCategory: ['Paralelo', 'Aplicaciones', 'Sistema'],
      description:
        "Un paradigma de programación es una manera o estilo de programación de software. Existen diferentes formas de diseñar un lenguaje de programación y varios modos de trabajar para obtener los resultados que necesitan los programadores. En las aplicaciones distribuidas, existen los paradigmas 'Sistema de Colas de Mensaje', los llamados 'Agentes Móviles', los 'Servicios de red' y el 'Espacio de objeto'.",
      description2: 
      "Dentro de las aplicaciones distribuidas, se encuentran distintos paradigmas que se diferencian para realizar estos sistemas informáticos, para ser más específicos, un paradigma significa una idea o un patrón de diseño y se rige ante un nivel de abstracción, desde el más bajo como transferencia de mensajes hasta el más alto, como objetos y sistemas de aplicaciones colaborativas. A continuación, están los paradigmas más conocidos: El primer paradigma, se llama Paso de mensajes o Transferencia de mensajes, y como concepto principal se encuentra la comunicación entre diversos procesos donde existe un remitente o receptor. Un proceso envía un mensaje, luego otro lo recepta y como respuesta reenvía otro mensaje distinto cuando una conexión esté abierta. El segundo paradigma, llamado Cliente-Servidor, parecido al Paso de mensajes, se encuentra una parte llamada Servidor donde provee servicios y espera la solicitud de un Cliente, hasta que esto no ocurra, el Servidor no hará comunicación alguna, aunque la conexión esté disponible. Este es el paradigma más utilizado por aplicaciones web, de escritorio y móviles. El tercer paradigma, se llama Peer-to-Peer (Punto a Punto ó Nodo-a-Nodo) es una transferencia mucho más fácil de implementar, ya que al no existir Servidor no hay una prioridad que provea información, todos los puntos o nodos pueden transferir información entre sí en cualquier momento en pares iguales. Otro paradigma funcional, se llama el del Sistema de Mensajes, ocurre cuando en la red existe un intermediario y conmutador, el emisor da un mensaje a la parte principal, luego llega a la parte del receptor, pero antes se procesa en una cola en la que está asociada, este intercambio de mensajes ocurre de forma asincrónica y desacoplada.",
      authorName: 'PAOLA ZAMBRANO',
      authorAvatar: '/assets/images/paola.jpeg',
      createdAt: '3 de junio/2022',
      cover: '/assets/images/apps2.png',
      refer: ['REPOSITORIO INSTITUTO SUPERIOR TECNOLOGICO CEMLAD, “Arquitecturas, paradigmas y aplicaciones de los sistemas distribuidos,” Academia.edu, Sep. 29, 2017. https://www.academia.edu/34717225/Arquitecturas_paradigmas_y_aplicaciones_de_los_sistemas_distribuidos (accessed Sep. 09, 2022).',
      '“Paradigmas de aplicaciones distribuidas – Acervo Lima,” Acervolima.com, 2019. https://es.acervolima.com/paradigmas-de-aplicaciones-distribuidas/ (accessed Sep. 09, 2022).'],
      imgs1:'/assets/images/Semana2_1.png',
      imgs2: '/assets/images/Semana2_2.png',
      imgs3:'/assets/images/Semana2_3.png',
    },
    {
      id: 3,
      title: 'El Protocolo TCP/IP',
      category: 'Cliente/Servidor',
      subCategory: ['Protocolo', 'Modelos', 'Lógica'],
      description:
        "Los protocolos son conjuntos de normas para formatos de mensaje y procedimientos que permiten a las máquinas y los programas de aplicación intercambiar información. Cada máquina implicada en la comunicación debe seguir estas normas para que el sistema principal de recepción pueda interpretar el mensaje. El conjunto de protocolos TCP/IP puede interpretarse en términos de capas (o niveles). Esta figura muestra las capas del protocolo TCP/IP. Empezando por la parte superior son: capa de aplicación, capa de transporte, capa de red, capa de interfaz de red y hardware.",
      description2: 'Los protocolos se consideran como un conjunto de reglas preestablecidos para determinar procedimientos y formatear mensajes dentro de las comunicaciones que permiten a las computadoras y las aplicaciones informáticas el intercambio de información dentro de una red. Cada máquina que se involucra en la comunicación tiene que seguir este conjunto de pautas para que la máquina receptora pueda interpretar y analizar el mensaje. Los Protocolos TCP/IP se dividen en capas o niveles. Para el Protocolo TCP/IP, se encuentran 5 capas, empezando por la capa física dentro de ella se encuentran las especificaciones del hardware que se van a utilizar para la red, están detallados las normas de hardware pertenecientes a la IEEE, medios físicos de Ethernet y para los conectores estándar. En la 2da capa, se encuentra el vínculo de datos donde están presenten las definiciones de los protocolos de red (TCP/IP), aquí es donde ocurren las depuraciones de errores, algunos ejemplos para la capa de vínculo de datos son las estructuras Ethernet IEEE 802.2 y protocolo punto a punto (PPP).',
      description3:'En la 3ra capa está la de internet, aquí está la transferencia de red y el protocolo principal de internet (IP), en la 4ta capa, denominada de Transporte está la verificación del transporte de paquetes, aquí se validan si llegaron correctamente a su destino, esto también es llamado conexión de punto-a-punto (Peer-to-Peer). En la última capa se definen las aplicaciones de red y los demás servicios que se proveen en Internet de manera estandarizada, aquí también participa la capa de transporte para el envío y recibo de datos, también se encuentran presentes algunos protocolos y demás servicios como los de directorio, archivos, servicio NFS y comandos indispensables (UNIX).',
      authorName: 'LIN SALINAS',
      authorAvatar: '/assets/images/salinas.jpeg',
      createdAt: '14 de junio/2022',
      cover: '/assets/images/apps3.jpg',
      refer: ['Introducción al conjunto de protocolos TCP/IP - Guía de administración del sistema: servicios IP,” Oracle.com, 2011. https://docs.oracle.com/cd/E24842_01/html/820-2981/ipov-6.html (accessed Sep. 09, 2022).', 'Qué es TCP/IP y características principales,” OpenWebinars.net, Jun. 18, 2019. https://openwebinars.net/blog/que-es-tcpip/ (accessed Sep. 09, 2022).'],
      imgs1:'/assets/images/Semana3_1.png',
      imgs2: '/assets/images/Semana3_2.png',
    },
    {
      id: 4,
      title: 'La Red, el Cliente y el Servidor',
      category: 'Cliente/Servidor',
      subCategory: ['Informática', 'Multicapa', 'Arquitectura'],
      description:
        "En las redes estructuradas bajo el modelo cliente servidor, los clientes centralizan diferentes aplicaciones y recursos en el servidor. El servidor, a su vez, se encarga de que estos recursos estén disponibles cada vez que un cliente los requiere.",
      description2: "El modelo de Cliente/Servidor se refiere a un modelo de diseño donde intervienen dos partes, la primera que es un Cliente y la otra, el Servidor. La tarea del Cliente es de solicitar servicios o información al servidor, la tarea del Servidor es la de almacenar datos y gestiona éstos en una base estructurada previamente desarrollada, pero la principal es la de proporcionar esta información al cliente cuando sólo si es solicitada. Un claro ejemplo para simplificar el funcionamiento del modelo de Cliente/Servidor es la misma internet o la World Wide Web, donde un Cliente o la “computadora-usuario” solicita a la red una página web, con una conexión estable, el tiempo de respuesta del servidor es óptimo y le entrega la página cargada. Entonces, el conjunto de computadoras conectadas alrededor del mundo. Dentro de este modelo, se pueden encontrar diversas arquitecturas, con la de 2 capas donde existen las partes principales de Cliente y Servidor, pero éste último no consta de una aplicación extra para brindar funcionalidades adicionales. En la arquitectura de tres capas se adiciona el nivel intermedio que es el encargado de proporcionar los recursos solicitados, pero requiere de otro servidor para hacerlo. Ya la última capa se denomina “de datos” que entrega la información proveniente de un gestor de base de datos. La última arquitectura es la de N Capas, pero comúnmente tiene 3 capas, se conforman por la capa de Datos, Negocio y Presentación, la de datos proporcionan los datos crudos, para luego pasarlos a la capa de Negocio, que los preparan para finalmente pasarlos a la capa de Presentación que no es nada más ni nada menos que la parte visual de la arquitectura y donde el usuario va a interactuar.",
        authorName: 'LIN SALINAS',
      authorAvatar: '/assets/images/salinas.jpeg',
      createdAt: '14 de junio/2022',
      cover: '/assets/images/apps4.png',
      refer: ['https://blog.infranetworking.com/modelo-cliente-servidor/', 'https://neo.lcc.uma.es/evirtual/cdd/tutorial/aplicacion/cliente-servidor.html#:~:text=Un%20servidor%20es%20una%20aplicaci%C3%B3n,mismo%20o%20en%20diferentes%20sistemas.'],
      imgs1:'/assets/images/Semana4_1.jpg',
      imgs2: '/assets/images/Semana4_2.jpg',
      imgs3:'/assets/images/Semana4_3.jpg',
    },
    {
      id: 5,
      title: 'El Protocolo UDP',
      category: 'Protocolos',
      subCategory: ['Modelos', 'Lógica', 'Datagramas'],
      description:
        "El protocolo UDP (Datagramas de usuario), es aquel que permite la transmisión de información sin conexión de los datagramas que están basados en protocolos IP, si bien este protocolo no es conocido como el TCP/IP, se clasifica en el nivel de transporte y, en consecuencia, se encuentra en una capa intermedia entre la capa de red y la capa de aplicación.",
      description2: "El Protocolo UDP (User Datagram Protocol) o el Protocolo de Datagramas de Usuario es un protocolo fundamental dentro de la Internet, permite un envío de datagramas sin previa conexión establecida, esto da paso a la presencia de los sockets en los puntos de destino para aceptar la información de origen. Este protocolo no consta de controles de flujo, es decir, este protocolo es uno no orientada a conexiones, a diferencia del TCP que sí lo tiene. Al no haber control dentro de este procotolo, cuando la red se encuentre saturada, es muy probable que muchos paquetes de información se pierdan y no automatización de reenvío, por eso este protocolo es considerado inseguro frente al TCP, donde ocurren controles de depuraciones ante anomalías y reenvían los paquetes que fueron detenidos por la saturación de la red. No hay garantías predefinidas en este protocolo, así que los paquetes transferidos llegarán a su destino y nunca se notificará si fueron recibidos correctamente por los receptores, tampoco proporciona un orden de datagramas enviados, así que esta clase de garantías se las puede añadir en capas superiores, si la lógica del sistema a desarrollar lo requiere, este protocolo es muy utilizado en la red cuando se tratan de transmisiones de audio y video, ya que se utiliza en DHCP y DNS donde es más importante la rapidez que la fiabilidad.",
        authorName: 'RICARDO TURRIAGO',
      authorAvatar: '/assets/images/turriago.jpg',
      createdAt: '14 de junio/2022',
      cover: '/assets/images/apps5.jpg',
      refer: ['https://www.redeszone.net/tutoriales/internet/tcp-udp-caracteristicas-uso-diferencias/', 'https://keepcoding.io/blog/que-es-el-protocolo-udp/ '],
      imgs1:'/assets/images/Semana5_1.png',
      imgs2: '/assets/images/Semana5_2.png',
      imgs3:'/assets/images/Semana5_3.jpg',
    },
    {
      id: 6,
      title: 'Los Sockets (Java)',
      category: 'Java',
      subCategory: ['Comunicación', 'Flujos', 'Streams'],
      description: "Los Sockets son puntos finales de enlaces de comunicaciones entre procesos. Los procesos los tratan como descriptores de ficheros, de forma que se pueden intercambiar datos con otros procesos transmitiendo y recibiendo a través de sockets. El tipo de sockets describe la forma en la que se transfiere información a través de ese socket.",
      description2:"WebSocket es una tecnología que proporciona un canal de comunicación bidireccional y full-duplex sobre un único socket TCP. Está diseñada para ser implementada en navegadores y servidores web, pero puede utilizarse por cualquier aplicación cliente/servidor. La API de WebSocket está siendo normalizada por el W3C, mientras que el protocolo WebSocket ya fue normalizado por la IETF como el RFC 6455. Debido a que las conexiones TCP comunes sobre puertos diferentes al 80 son habitualmente bloqueadas por los administradores de redes, el uso de esta tecnología proporcionaría una solución a este tipo de limitaciones proveyendo una funcionalidad similar a la apertura de varias conexiones en distintos puertos, pero multiplexando diferentes servicios WebSocket sobre un único puerto TCP. En el lado del cliente, WebSocket está ya implementado en Mozilla Firefox 8, Google Chrome 4 y Safari 5, así como la versión móvil de Safari en el iOS 4.2,1​ y en Internet Explorer 10. La implementación de cliente del protocolo WebSocket intenta detectar si el agente de usuario está configurado para utilizar un proxy a la hora de conectar a un host y puerto remoto, y si es así, utiliza el método HTTP CONNECT para establecer un túnel persistente.",
      description3:"Aunque el protocolo WebSocket es indiferente a la conexión sobre servidores proxy o cortafuegos, implementa una negociación compatible con HTTP para que los servidores HTTP puedan compartir sus puertos HTTP y HTTPS por defecto (80 y 443) con una pasarela o servidor WebSocket. El protocolo WebSocket define un prefijo ws:// y wss:// para indicar una conexión WebSocket y Websocket Secure, respectivamente. Ambos esquemas utilizan un mecanismo HTTP upgrade para actualizar al protocolo WebSocket.",
      authorName: 'RICARDO TURRIAGO',
      authorAvatar: '/assets/images/turriago.jpg',
      createdAt: '03 de julio/2022',
      cover: '/assets/images/Semana6_1.jpg',
      refer: ['https://developer.mozilla.org/es/docs/Web/API/WebSockets_API', 'https://socket.io/docs/v4/'],
      imgs1:'/assets/images/Semana6_1.jpg',
      imgs2: '/assets/images/Semana6_2.jpg',
      imgs3:'/assets/images/Semana6_3.jpg',
    },
    {
      id: 7,
      title: 'Programación Distribuida - Objetos distribuidos en Java: RPC',
      category: 'Java',
      subCategory: ['Comunicación', 'Flujos'],
      description:"La programación distribuida es un paradigma de programación enfocado en desarrollar sistemas distribuidos, abiertos, escalables, transparentes y tolerantes de fallos. Este paradigma es el resultado natural del uso de las computadoras y las redes.",
      description2: "En computación distribuida, la llamada a procedimiento remoto es un programa que utiliza una computadora para ejecutar código en otra máquina remota sin tener que preocuparse por las comunicaciones entre ambas, de forma que parezca que se ejecuta en local. El protocolo que se utiliza para esta llamada es un gran avance sobre los sockets de Internet usados hasta el momento. De esta manera el programador no tenía que estar pendiente de las comunicaciones, estando estas encapsuladas dentro de las RPC. Una llamada a procedimiento es muy similar a una invocación a un método remoto en la que un programa cliente llama a un procedimiento de otro programa en ejecución en un proceso servidor.",
      description3: "Los servidores pueden ser clientes de otros servidores para permitir cadenas de RPC. Un proceso servidor define en su interfaz de servicio los procedimientos disponibles para ser llamados remotamente. RPC se implementa usualmente sobre protocolo petición-respuesta, que se encuentra simplificado por omisión de de referencias a objetos remotos en la parte de los mensajes de petición. Las RPC son muy utilizadas dentro de la comunicación cliente-servidor. Siendo el cliente el que inicia el proceso solicitando al servidor que ejecute cierto procedimiento o función y enviando este de vuelta el resultado de dicha operación al cliente. El cliente que accede a un servicio incluye un procedimiento de resguardo para cada procedimiento en la interfaz de servicio. El papel de un procedimiento de resguardo es similar al de un proxy. Se comporta como un procedimiento local del cliente pero en lugar de ejecutar la llamada, empaqueta el identificador del procedimiento y los argumentos en un mensaje de petición que se envía vía su módulo de comunicación al servidor; cuando llega el mensaje de respuesta, desempaqueta los resultados.",
      authorName: 'PAOLA ZAMBRANO',
      authorAvatar: '/assets/images/paola.jpeg',
      createdAt: '10 de julio/2022',
      cover: '/assets/images/Semana7_1.jpg',
      refer: ['https://www.ibm.com/docs/es/radfws/9.6.1?topic=applications-jax-rpc-jsr-101', 'https://www.ibm.com/docs/es/rsm/7.5.0?topic=standards-jax-rpc'],
      imgs1:'/assets/images/Semana7_2.jpg',
      imgs2: '/assets/images/Semana7_3.jpg',
    },
    {
      id: 8,
      title: 'Programación Distribuida - Objetos distribuidos en Java: RMI - Comparativa entre RMI y RPC',
      category: 'Java',
      subCategory: ['Comunicación', 'Flujos'],
      description: "RMI es un mecanismo que permite realizar llamadas a métodos de objetos remotos situados en distintas (o la misma) máquinas virtuales Java, compartiendo así recursos y carga de procesamiento a través de varios sistemas.",
      description2: "Permite exportar objetos como objetos remotos para que otro proceso remoto pueda acceder directamente como un objeto Java. Todos los objetos de una aplicación distribuida basada en RMI deben ser implementados en Java. Esta es una de las principales ventajas de RMI, ya que RMI forma parte del API de Java, con lo que la integración de objetos remotos en aplicaciones distribuidas se realiza sin necesidad de usar recursos adicionales (como por ejemplo un lenguaje de descripción de interfaces o IDL). De hecho, se utiliza la misma sintaxis para una llamada a un objeto remoto o un objeto local. El cliente invoca a los objetos remotos mediante la interfaz remota. Un servicio de nombres (registro RMI) reside en el host proporcionando el mecanismo que el cliente usa para encontrar uno más servidores iniciales RMI. La interacción con el objeto remoto se lleva a cabo a través de la interfaz remota. Esencialmente, ésta describe los métodos que pueden ser invocados de forma remota, y que el objeto remoto implementa. Cuando se obtiene una referencia a un objeto remoto, el objeto no se envía a través de la red al cliente que lo solicita. En su lugar se genera un objeto proxy o stub que constituye el proxy de la parte del cliente del objeto remoto. Todas las interacciones del cliente se realizarán con esta clase stub, la cual es responsable de gestionar los datos entre el sistema local y el remoto. Muchos clientes pueden tener referencias a un único objeto remoto. Cada cliente tiene su propio objeto stub que representa al objeto remoto, pero dicho objeto remoto NO se replica. En la parte del servidor, una clase skeleton es la responsable de gestionar las llamadas al método y los datos enviados al objeto real referenciado. Éste es el proxy de la parte del servidor para el objeto remoto.",
      description3: "La llamada a procedimiento remoto (RPC) es una función de lenguaje de programación diseñada para la computación distribuida y basada en la semántica de las llamadas a procedimientos locales. Es la forma más común de servicio remoto y se diseñó como una forma de abstraer el mecanismo de llamada de procedimiento para usar entre sistemas conectados a través de una red. Es similar al mecanismo de IPC en el que el sistema operativo permite que los procesos gestionen los datos compartidos y se ocupen de un entorno en el que los diferentes procesos se ejecutan en sistemas separados y necesariamente requieren comunicación basada en mensajes. La invocación de método remoto (RMI) es similar a RPC pero es específica del idioma y una característica de Java. Se permite que un hilo llame al método en un objeto remoto. Para mantener la transparencia en el lado del cliente y del servidor, implementa objetos remotos utilizando apéndices y esqueletos. El código auxiliar reside en el cliente y, para el objeto remoto, se comporta como un proxy. Cuando un cliente llama a un método remoto, se llama al código auxiliar del método remoto. El talón del cliente es responsable de crear y enviar el paquete que contiene el nombre de un método y los parámetros calculados, y el esqueleto es responsable de recibir el paquete. Diferencias clave entre RPC y RMI. 1) RPC admite los paradigmas de programación de procedimientos, por lo tanto, está basado en C, mientras que RMI admite paradigmas de programación orientados a objetos y está basado en Java. 2) Los parámetros pasados a procedimientos remotos en RPC son las estructuras de datos ordinarias. Por el contrario, RMI transita objetos como un parámetro al método remoto. 3) RPC se puede considerar como la versión anterior de RMI, y se usa en los lenguajes de programación que admiten la programación de procedimientos, y solo se puede usar el método de paso por valor. A diferencia de lo anterior, la facilidad de RMI está diseñada en base a un enfoque de programación moderno, que podría usar el paso por valor o referencia. Otra ventaja de RMI es que los parámetros pasados por referencia se pueden cambiar. 4) El protocolo RPC genera más gastos generales que RMI. 5) Los parámetros pasados en RPC deben ser in-out, lo que significa que el valor pasado al procedimiento y el valor de salida deben tener los mismos tipos de datos. En contraste, no hay obligación de pasar parámetros de entrada-salida en RMI.",
      authorName: 'LIN SALINAS',
      authorAvatar: '/assets/images/salinas.jpeg',
      createdAt: '17 de julio/2022',
      cover: '/assets/images/Semana8_1.jpg',
      refer: ['http://www.jtech.ua.es/j2ee/2003-2004/modulos/rmi/sesion01-apuntes.htm', 'http://www.jtech.ua.es/historico/paj/restringido/apuntes/sesion13-apuntes.htm', 'https://www.ibm.com/docs/es/was-nd/8.5.5?topic=rpc-rmi-iiop-using-jax', 'https://www.ibm.com/docs/es/was/9.0.5?topic=rpc-rmi-iiop-using-jax'],
      imgs1:'/assets/images/Semana8_2.jpg',
      imgs2: '/assets/images/Semana8_3.jpg',
      imgs3:'/assets/images/Semana8_4.jpg',
    },
    {
      id: 9,
      title: 'Hilos - Conceptos - Interfaces - Ciclo de vida de un hilo',
      category: 'Java',
      subCategory: ['Comunicación', 'Flujos'],
      description: "La Máquina Virtual Java (JVM) es un sistema multihilo. Es decir, es capaz de ejecutar varios hilos de ejecución simultáneamente. La JVM gestiona todos los detalles, asignación de tiempos de ejecución, prioridades, etc., de forma similar a como gestiona un Sistema Operativo múltiples procesos.",
      description2: "La diferencia básica entre un proceso de Sistema Operativo y un Thread Java es que los hilos corren dentro de la JVM, que es un proceso del Sistema Operativo y por tanto comparten todos los recursos, incluida la memoria y las variables y objetos allí definidos. A este tipo de procesos donde se comparte los recursos se les llama a veces procesos ligeros (lightweight process). Java da soporte al concepto de Thread desde el propio lenguaje, con algunas clases e interfaces definidas en el paquete java.lang y con métodos específicos para la manipulación de Threads en la clase Object.",
      description3: "Un hilo tiene un ciclo de vida que va desde su creación hasta su terminación. Estado Nuevo o Creado: Cuando un hilo está en este estado, es simplemente un objeto Thread vacío. El sistema no ha destinado ningún recurso para él. Desde este estado solamente puede arrancarse llamando al método start(), o detenerse definitivamente, llamando al método stop(). Estado En ejecución o Iniciado: La llamada al método start() creará los recursos del sistema necesarios para que el hilo puede ejecutarse, lo incorpora a la lista de procesos disponibles para ejecución del sistema y llama al método run() del hilo de ejecución. Estado Detenido o Parado: El hilo de ejecución entra en estado Parado cuando alguien llama al método suspend(), cuando se llama al método sleep(), cuando el hilo está bloqueado en un proceso de entrada/salida o cuando el hilo utiliza su método wait() para esperar a que se cumpla una determinada condición. Estado Muerto o Terminado: Un hilo de ejecución se puede morir de dos formas: por causas naturales o porque lo maten (con stop()). Un hilo muere normalmente cuando concluye de forma habitual su método run().",
      authorName: 'LIN SALINAS',
      authorAvatar: '/assets/images/salinas.jpeg',
      createdAt: '24 de julio/2022',
      cover: '/assets/images/Semana9_1.jpg',
      refer: ['http://www.jtech.ua.es/dadm/restringido/java/sesion05-apuntes.html'],
      imgs1:'/assets/images/Semana9_2.jpg',
      imgs2: '/assets/images/Semana9_3.jpg',
      imgs3:'/assets/images/Semana9_4.jpg',
    },
    {
      id: 10,
      title: 'Hilos - Hilos y prioridades - Sincronización de hilos',
      category: 'Java',
      subCategory: ['Comunicación', 'Flujos'],
      description: "",
      description2: "",
      description3: "",
      authorName: 'PAOLA ZAMBRANO',
      authorAvatar: '/assets/images/paola.jpeg',
      createdAt: '31 de julio/2022',
      cover: '/assets/images/Semana10_1.jpg',
      refer: [''],
      imgs1:'/assets/images/Semana10_2.jpg',
      imgs2: '/assets/images/Semana10_3.jpg',
      imgs3:'/assets/images/Semana10_4.jpg',
    },
  ];
  